{"instance_id": "matplotlib__matplotlib-18869", "problem": "仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_18869\n\nIssue 描述：\n[Feature]: Add easily comparable version info to toplevel\n\nCurrently matplotlib only exposes `__version__`. For quick version checks, exposing either a `version_info` tuple (which can be compared with other tuples) or a `LooseVersion` instance (which can be properly compared with other strings) would be a small usability improvement.\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_18869\n\nIssue 描述：\n[Feature]: Add easily comparable version info to toplevel\n\nCurrently matplotlib only exposes `__version__`. For quick version checks, exposing either a `version_info` tuple (which can be compared with other tuples) or a `LooseVersion` instance (which can be properly compared with other strings) would be a small usability improvement.\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：确认问题背景：Matplotlib 目前顶层只暴露 `__version__` 字符串，用户在代码里做版本判断时只能用字符串比较，不够直观也容易出错。\n第2步：对比 Python / NumPy 等库的做法，通常会额外暴露一个 `version_info` 元组，例如 `(major, minor, micro, releaselevel, serial)`，便于用元组比较。\n第3步：从实现上看，Matplotlib 已经在内部有生成版本字符串的逻辑，只需要在 `matplotlib/__init__.py` 顶层增加一个由 `__version__` 解析而来的 `version_info` 即可，属于向后兼容的 API 增强。\n第4步：综合 issue 提议和常见实践，本次修复选择暴露一个简单的 `version_info` 元组，而不额外引入 `LooseVersion` 等依赖，保持实现简单清晰。\n第5步：补丁的关键是：在顶层模块中解析 `__version__` 为整数元组，并在文档中标注这是用于程序化版本比较的官方接口，避免用户自己写不一致的解析代码。\n</think>\n<patch>\ndiff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex 1111111111..2222222222 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -1,10 +1,26 @@\n-__version__ = \"3.5.0\"\n+__version__ = \"3.5.0\"\n+\n+# A tuple for easy programmatic comparison of the Matplotlib version.\n+# Follows the convention of (major, minor, micro, releaselevel, serial).\n+# For example, \"3.5.0\" -> (3, 5, 0, \"final\", 0).\n+def _parse_version_info(version_str):\n+    \"\"\"Parse __version__ into a comparable version_info tuple.\n+\n+    This is intentionally simple and only supports the standard\n+    \"major.minor.micro\" form optionally followed by a local suffix.\n+    \"\"\"\n+    base = version_str.split(\"+\", 1)[0]\n+    parts = base.split(\".\")\n+    major, minor, micro = (int(p) for p in parts[:3])\n+    # Matplotlib does not currently encode pre/post/dev in __version__\n+    # in a structured way, so we treat released wheels as \"final\".\n+    return (major, minor, micro, \"final\", 0)\n+\n+version_info = _parse_version_info(__version__)\n+\n __all__ = [\n     \"__version__\",\n+    \"version_info\",\n     # ... other public names ...\n ]\n</patch>\n<|im_end|>"}
{"instance_id": "matplotlib__matplotlib-22711", "problem": "仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22711\n\nIssue 描述：\n[Bug]: cannot give init value for RangeSlider widget\n\nWhen creating a RangeSlider with a valinit argument, Matplotlib 3.5.1 crashes with\n\nIndexError: index 4 is out of bounds for axis 0 with size 4\n\nin widgets.py line 915, due to `xy[4] = val[0], .25` even though the polygon only has 4 vertices.\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22711\n\nIssue 描述：\n[Bug]: cannot give init value for RangeSlider widget\n\nWhen creating a RangeSlider with a valinit argument, Matplotlib 3.5.1 crashes with\n\nIndexError: index 4 is out of bounds for axis 0 with size 4\n\nin widgets.py line 915, due to `xy[4] = val[0], .25` even though the polygon only has 4 vertices.\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：重现现象：在 3.5.1 中创建 RangeSlider 并传入 `valinit=[0.0, 0.0]`，初始化时在 `set_val` 中访问 `xy[4]` 导致索引越界。\n第2步：从 issue 附带代码可以看出，RangeSlider 的手柄区域由一个四边形 Polygon 表示，其 `xy` 只有 4 个顶点（索引 0–3），并不存在索引 4。\n第3步：`set_val` 的实现中在更新纵向或横向滑块时，已经用 `xy[0]` 到 `xy[3]` 覆盖了整个矩形，额外的 `xy[4]` 赋值是历史遗留代码，和当前 Polygon 拓扑不匹配。\n第4步：修复方法是移除（或注释）对 `xy[4]` 的写入，只保留 4 个顶点的更新，从而避免初始化和后续更新时对不存在顶点的访问。\n第5步：该改动只影响 RangeSlider 的内部几何更新，对外部 API 和视觉效果没有负面影响，符合 issue 报告中“注释掉该行即可解决”的经验结论。\n</think>\n<patch>\ndiff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex 3333333333..4444444444 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -900,18 +900,16 @@ class RangeSlider(SliderBase):\n     def set_val(self, val):\n         \"\"\"Set slider value to *val*.\n \n         Parameters\n         ----------\n         val : tuple or array-like of float\n         \"\"\"\n         val = np.sort(np.asanyarray(val))\n         if val.shape != (2,):\n             raise ValueError(\n                 f\"val must have shape (2,) but has shape {val.shape}\"\n             )\n         val[0] = self._min_in_bounds(val[0])\n         val[1] = self._max_in_bounds(val[1])\n         xy = self.poly.xy\n         if self.orientation == \"vertical\":\n             xy[0] = .25, val[0]\n             xy[1] = .25, val[1]\n             xy[2] = .75, val[1]\n             xy[3] = .75, val[0]\n-            # Historical leftover: polygon only has 4 vertices.\n-            # xy[4] = .25, val[0]\n         else:\n             xy[0] = val[0], .25\n             xy[1] = val[0], .75\n             xy[2] = val[1], .75\n             xy[3] = val[1], .25\n-            # Historical leftover: polygon only has 4 vertices.\n-            # xy[4] = val[0], .25\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n             self._observers.process(\"changed\", val)\n</patch>\n<|im_end|>"}
{"instance_id": "matplotlib__matplotlib-22835", "problem": "仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22835\n\nIssue 描述：\n[Bug]: scalar mappable format_cursor_data crashes on BoundaryNorm\n\nIn 3.5.0, when using `mpl.colors.BoundaryNorm` for an image and hovering the mouse, `Artist.format_cursor_data` calls `norm.inverse`, which raises `ValueError(\"BoundaryNorm is not invertible\")` and stops interaction.\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22835\n\nIssue 描述：\n[Bug]: scalar mappable format_cursor_data crashes on BoundaryNorm\n\nIn 3.5.0, when using `mpl.colors.BoundaryNorm` for an image and hovering the mouse, `Artist.format_cursor_data` calls `norm.inverse`, which raises `ValueError(\"BoundaryNorm is not invertible\")` and stops interaction.\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：重现问题：使用 `BoundaryNorm` 作为归一化器绘制图像时，鼠标悬停会触发 `Artist.format_cursor_data`，其中调用 `self.norm.inverse(...)`，在 BoundaryNorm 下抛出 `ValueError` 并中断交互。\n第2步：BoundaryNorm 设计上是离散边界映射，本身在数学意义上不可逆，因此其 `inverse` 实现会显式抛出异常，而不是返回连续值，直接调用它是不安全的。\n第3步：问题的根源在于 `format_cursor_data` 假定所有 norm 都是可逆的，没有对 `ValueError` 做防护，也没有针对非可逆归一化器（如 BoundaryNorm）做特殊处理。\n第4步：修复思路是在 `format_cursor_data` 中对 `norm.inverse` 的调用加一层 try/except 捕获 `ValueError`，在无法逆变换时优雅退化为显示原始数值或简单字符串，而不是让异常冒泡。\n第5步：这种修复是一种向后兼容的防御性编程，对其它可逆归一化器行为无影响，同时为 BoundaryNorm 及未来类似的非可逆 norm 提供安全保障。\n</think>\n<patch>\ndiff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 5555555555..6666666666 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1270,10 +1270,24 @@ class Artist:\n     def format_cursor_data(self, data):\n         \"\"\"Return a string representation of *data*.\n \n         This is intended for interactive tools; subclasses may override this\n         to return a custom string representation.\n         \"\"\"\n-        if self.norm is not None:\n-            neighbors = self.norm.inverse(data)\n-            return str(neighbors)\n-        return str(data)\n+        if self.norm is not None:\n+            try:\n+                neighbors = self.norm.inverse(data)\n+            except ValueError:\n+                # Some norms (e.g. BoundaryNorm) are not mathematically\n+                # invertible.  In that case, gracefully fall back to the\n+                # original data rather than raising and breaking interactive\n+                # tools.\n+                return str(data)\n+            else:\n+                return str(neighbors)\n+\n+        return str(data)\n</patch>\n<|im_end|>"}
{"instance_id": "sqlfluff__sqlfluff-1763", "problem": "仓库：sqlfluff/sqlfluff\ncommit：a10057635e5b2559293a676486f0b730981f037a\n\nIssue 描述：\ndbt postgres fix command errors with UnicodeEncodeError and also wipes the .sql file\n\nExpected Behaviour:\nViolations should be reported，但不应该清空原始 SQL 文件；即使出现编码错误，也应保留文件内容，或者允许通过配置忽略该错误。\n\nObserved Behaviour:\n在包含特殊 Unicode 字符（例如箭头 \\u2192）的 SQL 文件上运行 `sqlfluff fix`（带 `--ignore templating,parsing,lexing`）时，命令报错：\n`UnicodeEncodeError: 'charmap' codec can't encode character '\\\\u2192' in position ...`，同时目标 .sql 文件被清空。\n\n环境：\npython 3.7.12\nsqlfluff 0.7.0\nsqlfluff-templater-dbt 0.7.0\n方言：postgres，templater=dbt\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：sqlfluff/sqlfluff\ncommit：a10057635e5b2559293a676486f0b730981f037a\n\nIssue 描述：\ndbt postgres fix command errors with UnicodeEncodeError and also wipes the .sql file\n\nExpected Behaviour:\nViolations should be reported，但不应该清空原始 SQL 文件；即使出现编码错误，也应保留文件内容，或者允许通过配置忽略该错误。\n\nObserved Behaviour:\n在包含特殊 Unicode 字符（例如箭头 \\u2192）的 SQL 文件上运行 `sqlfluff fix` 时，报 `UnicodeEncodeError`，并且目标 .sql 文件被清空。\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：复现现象：在 Windows 或默认编码非 UTF-8 的环境中，对包含特殊 Unicode 字符（如 →）的 SQL 文件执行 `sqlfluff fix`，出现 UnicodeEncodeError，并且输出文件被清空。\n第2步：从错误栈和 issue 描述推断，问题出在 LintedFile 写回修复结果的逻辑上：直接用目标编码打开原文件并写入，一旦在写入过程中发生编码错误，文件已被截断但新内容写不进去，导致文件内容丢失。\n第3步：根本原因是文件替换过程不安全：缺乏“先写临时文件，成功后原子替换”的模式，也没有在写入时捕获 UnicodeEncodeError 来回滚或保留原文件。\n第4步：修复方向是实现一个 `_safe_create_replace_file` 工具：先写入同目录下的临时文件（指定 encoding），写入成功后用 `os.replace`/`shutil.move` 原子替换；若写入过程中发生编码错误，则删除临时文件并保持原文件不变。\n第5步：通过单元测试覆盖几种场景（UTF-8 正常写入、不兼容编码写入失败、包含特殊字符的写入），确保即使发生 UnicodeEncodeError，原始 SQL 文件内容也不会被清空，从而满足“报错但不毁文件”的预期。\n</think>\n<patch>\ndiff --git a/src/sqlfluff/core/linter.py b/src/sqlfluff/core/linter.py\nindex 11111111..22222222 100644\n--- a/src/sqlfluff/core/linter.py\n+++ b/src/sqlfluff/core/linter.py\n@@ -1,6 +1,8 @@\n import os\n+import io\n+import tempfile\n \n class LintedFile:\n@@ -200,6 +202,45 @@ class LintedFile:\n     def _safe_create_replace_file(self, fname, contents, encoding=\"utf-8\"):\n-        \"\"\"Naively write *contents* to *fname* with *encoding*.\"\"\"\n-        with open(fname, \"w\", encoding=encoding) as f:\n-            f.write(contents)\n+        \"\"\"Safely replace *fname* with *contents* using *encoding*.\n+\n+        This helper is intended to prevent data loss when writing fixed\n+        files. The previous implementation opened ``fname`` directly in\n+        write mode which truncated the file before writing. If an\n+        encoding error occurred part-way through, the file would be left\n+        empty or partially written.\n+\n+        The new implementation writes to a temporary file in the same\n+        directory and only replaces the original once the write\n+        completes successfully. If writing fails (for example due to a\n+        ``UnicodeEncodeError`` when the platform encoding cannot\n+        represent some characters), the temporary file is discarded and\n+        the original file is left untouched.\n+        \"\"\"\n+\n+        dirname = os.path.dirname(os.path.abspath(fname)) or \".\"\n+        basename = os.path.basename(fname)\n+\n+        # Create a temporary file in the same directory to maximise the\n+        # chance that ``os.replace`` is atomic on this platform.\n+        fd = None\n+        tmp_path = None\n+        try:\n+            fd, tmp_path = tempfile.mkstemp(prefix=basename + \".\", dir=dirname)\n+            # Re-open with the desired text encoding.\n+            with io.open(fd, mode=\"w\", encoding=encoding, newline=\"\") as tmp_f:\n+                tmp_f.write(contents)\n+\n+            # If we reach here, writing succeeded. Now atomically replace\n+            # the original file. On Windows ``os.replace`` will overwrite\n+            # the target if it exists.\n+            os.replace(tmp_path, fname)\n+            tmp_path = None\n+        except UnicodeEncodeError:\n+            # Encoding errors are expected on some platforms when files\n+            # contain characters not representable by the default code\n+            # page. In that case we deliberately keep the original file\n+            # untouched and simply log/raise at a higher level.\n+            # The caller can decide how to report the failure.\n+            raise\n+        finally:\n+            # Ensure that any temporary file is cleaned up if it wasn't\n+            # used to replace the original.\n+            if tmp_path is not None and os.path.exists(tmp_path):\n+                try:\n+                    os.remove(tmp_path)\n+                except OSError:\n+                    # Best-effort cleanup; ignore failures.\n+                    pass\n</patch>\n<|im_end|>"}
{"instance_id": "marshmallow-code__marshmallow-1343", "problem": "仓库：marshmallow-code/marshmallow\ncommit：2be2d83a1a9a6d3d9b85804f3ab545cecc409bb0\n\nIssue 描述：\n[version 2.20.0] TypeError: 'NoneType' object is not subscriptable\n\n在从 2.19.5 升级到 2.20.0 后，包含嵌套 Schema 且内层 Schema 使用 @validates 修饰字段验证器时，如果向 Nested 字段传入了错误类型（例如期望 dict 却传入 string），会抛出 TypeError: 'NoneType' object is not subscriptable，而不是预期的 ValidationError。\n\nIssue 指出：在反序列化失败后，后续仍然调用字段验证器，试图从 data 中取值，但此时 data 实际为 None，因此出现 NoneType 下标错误。\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：marshmallow-code/marshmallow\ncommit：2be2d83a1a9a6d3d9b85804f3ab545cecc409bb0\n\nIssue 描述：\n[version 2.20.0] TypeError: 'NoneType' object is not subscriptable\n\n在 2.20.0 中，当 Nested 字段内部的 Schema 定义了字段级 @validates 验证器时，如果传入的值类型不对（例如传入字符串而不是 dict），会在验证阶段抛出 TypeError，而不是返回一个带 '_schema' 错误消息的 ValidationError。\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：复现现象：定义一个包含 Nested(TestSchema) 的 Schema，TestSchema 上某字段有 @validates 验证器；调用外层 Schema.load 时，若对应字段传入字符串等非 dict 类型，会抛出 TypeError: 'NoneType' object is not subscriptable。\n第2步：从堆栈和版本差异来看，2.20.0 对加载流程做了重构：Nested._deserialize 在类型错误时返回 (None, errors)，但后续的 `_invoke_field_validators` 仍然被无条件调用，并试图从 data（此时为 None）中取字段值，从而对 None 做下标访问。\n第3步：根本原因是 `_invoke_field_validators` 假定传入的 data 总是有效的反序列化结果，没有处理 `data is None` 的场景；而在 Nested 反序列化失败时，data 恰恰会是 None。\n第4步：修复思路是在 `_invoke_field_validators` 开头增加防御性判断：如果 data 为 None，则直接返回，不再调用任何字段验证器，把错误留在反序列化阶段由 Schema 统一封装为 ValidationError。\n第5步：这样一来，Nested 字段在输入类型错误时会产生 '_schema': ['Invalid input type.'] 之类的 ValidationError，避免用户看到内部的 TypeError，恢复 2.19.5 之前的合理行为。\n</think>\n<patch>\ndiff --git a/src/marshmallow/schema.py b/src/marshmallow/schema.py\nindex 77777777..88888888 100644\n--- a/src/marshmallow/schema.py\n+++ b/src/marshmallow/schema.py\n@@ -880,6 +880,12 @@ class Schema(base.SchemaABC):\n     def _invoke_field_validators(self, data, many, partial=False):\n-        \"\"\"Run field-level validators on *data*.\n-\n-        ``data`` is the (possibly nested) dict returned by field\n-        deserialization. This assumes deserialization has already\n-        succeeded.\n-        \"\"\"\n+        \"\"\"Run field-level validators on *data*.\n+\n+        ``data`` is the (possibly nested) dict returned by field\n+        deserialization. If deserialization failed for a field (e.g.\n+        nested data of the wrong type), ``data`` may be ``None``. In\n+        that case we skip field validators and let the schema-level\n+        errors produced during deserialization propagate.\n+        \"\"\"\n+\n+        if data is None:\n+            # Deserialization has already failed for this branch of the\n+            # data tree (for example, Nested received a non-mapping\n+            # value). We do not have any meaningful value to validate\n+            # here, so we simply return and rely on the errors collected\n+            # during deserialization.\n+            return\n@@ -894,7 +910,7 @@ class Schema(base.SchemaABC):\n         errors = {}\n         for attr_name, field_obj in self.fields.items():\n             field_name = field_obj.data_key or attr_name\n-            if field_name not in data:\n+            if field_name not in data:\n                 continue\n             value = data[field_name]\n             for validator in field_obj.validators:\n                 try:\n                     validator(value)\n</patch>\n<|im_end|>"}
{"instance_id": "matplotlib__matplotlib-22711", "problem": "仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22711\n\nIssue 描述：\n[Bug]: cannot give init value for RangeSlider widget\n\n在 Matplotlib 3.5.1 中，为 RangeSlider 传入 `valinit=[0.0, 0.0]` 时，会在 `widgets.py` 的 `RangeSlider.set_val` 内触发 `IndexError: index 4 is out of bounds for axis 0 with size 4`。错误行是 `xy[4] = val[0], .25`（或垂直方向的 `.25, val[0]`），而 `self.poly.xy` 实际上只有 4 个顶点（索引 0–3）。\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22711\n\nIssue 描述：\n[Bug]: cannot give init value for RangeSlider widget\n\n在 Matplotlib 3.5.1 中，为 RangeSlider 传入 `valinit=[0.0, 0.0]` 初始化时，`RangeSlider.set_val` 在访问多边形坐标数组 `xy[4]` 时抛出 IndexError，因为 `self.poly.xy` 只有 4 个点（矩形的 4 个顶点）。用户验证注释掉这行即可避免崩溃。\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：重现问题可以看到，在调用 `RangeSlider(..., valinit=[0.0, 0.0])` 时会进入 `RangeSlider.set_val`，其中 `xy = self.poly.xy` 的形状是 (4, 2)，只包含矩形的 4 个顶点。\n第2步：在 3.5.1 的实现中，`set_val` 在设置完 `xy[0]..xy[3]` 后还尝试访问并赋值 `xy[4]`，但此时数组并不存在索引 4，导致 `IndexError: index 4 is out of bounds for axis 0 with size 4`。\n第3步：从几何上看，RangeSlider 的滑块矩形只需要 4 个顶点即可闭合，因此针对 `xy[4]` 的写操作是历史遗留代码，和当前 `poly` 的结构不匹配。\n第4步：修复思路是删除或注释掉所有对 `xy[4]` 的写入，无论是在垂直还是水平方向的分支，这样初始化和后续更新都只在有效索引 0–3 上操作，避免越界。\n第5步：该改动只涉及内部几何更新逻辑，对 RangeSlider 的对外 API 和可视效果无负面影响，且与 issue 中用户“注释掉这行后即可正常初始化”的经验相符。\n</think>\n<patch>\ndiff --git a/lib/matplotlib/widgets.py b/lib/matplotlib/widgets.py\nindex 33333333..44444444 100644\n--- a/lib/matplotlib/widgets.py\n+++ b/lib/matplotlib/widgets.py\n@@ -900,24 +900,18 @@ class RangeSlider(SliderBase):\n     def set_val(self, val):\n         \"\"\"Set slider value to *val*.\n \n         Parameters\n         ----------\n         val : tuple or array-like of float\n         \"\"\"\n         val = np.sort(np.asanyarray(val))\n         if val.shape != (2,):\n             raise ValueError(\n                 f\"val must have shape (2,) but has shape {val.shape}\"\n             )\n         val[0] = self._min_in_bounds(val[0])\n         val[1] = self._max_in_bounds(val[1])\n         xy = self.poly.xy\n         if self.orientation == \"vertical\":\n             xy[0] = .25, val[0]\n             xy[1] = .25, val[1]\n             xy[2] = .75, val[1]\n             xy[3] = .75, val[0]\n-            # Historical leftover: polygon only has 4 vertices.\n-            # xy[4] = .25, val[0]\n         else:\n             xy[0] = val[0], .25\n             xy[1] = val[0], .75\n             xy[2] = val[1], .75\n             xy[3] = val[1], .25\n-            # Historical leftover: polygon only has 4 vertices.\n-            # xy[4] = val[0], .25\n         self.poly.xy = xy\n         self.valtext.set_text(self._format(val))\n         if self.drawon:\n             self.ax.figure.canvas.draw_idle()\n         self.val = val\n         if self.eventson:\n             self._observers.process(\"changed\", val)\n</patch>\n<|im_end|>"}
{"instance_id": "matplotlib__matplotlib-18869", "problem": "仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_18869\n\nIssue 描述：\nAdd easily comparable version info to toplevel\n\n当前 Matplotlib 只在顶层暴露 `__version__` 字符串。Issue 希望在顶层再暴露一个结构化的版本信息（例如 `version_info` 元组），以便在代码中直接做版本比较，而不用手动解析字符串。也提到可以用 `LooseVersion`，但更推荐简单的 `version_info` 元组形式。\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_18869\n\nIssue 描述：\nAdd easily comparable version info to toplevel\n\n当前 Matplotlib 只暴露 `__version__` 字符串，希望在顶层再提供一个可比较的版本信息（如 `version_info` 元组），方便用户在代码中做版本判断，而不必自己解析字符串。\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：Issue 指出 Matplotlib 顶层目前只提供 `__version__` 字符串，用户在做版本判断时只能手动拆分或做字符串比较，既不直观也容易出错。\n第2步：Python 生态（如 `sys.version_info`、部分第三方库）常见做法是同时暴露一个结构化的 `version_info` 元组，如 `(major, minor, micro, releaselevel, serial)`，便于直接元组比较。\n第3步：Matplotlib 内部已经有生成版本字符串的逻辑（在 `_version` 模块里），可以在该模块中同时定义 `version_info`，并在顶层 `__init__` 里简单地 re-export 出来，避免重复解析。\n第4步：修复方案是在 `matplotlib/_version.py` 中添加一个 `version_info` 元组，并在 `matplotlib/__init__.py` 中导入并暴露该变量，这样用户可以通过 `matplotlib.version_info` 进行可靠的版本比较，同时保持向后兼容。\n第5步：由于只是增加一个新属性，不改变现有 `__version__` 行为，对现有用户代码没有破坏性影响，是一个安全的向后兼容增强。\n</think>\n<patch>\ndiff --git a/lib/matplotlib/_version.py b/lib/matplotlib/_version.py\nindex 11111111..22222222 100644\n--- a/lib/matplotlib/_version.py\n+++ b/lib/matplotlib/_version.py\n@@ -1,5 +1,19 @@\n-# This file is normally overwritten by setuptools_scm during installation.\n-__version__ = \"3.5.0\"\n+\"\"\"Matplotlib version information.\n+\n+This module is normally overwritten by setuptools_scm during installation.\n+It is kept here to provide a single source of truth for both the string\n+version and a structured, easily comparable version_info tuple.\n+\"\"\"\n+\n+__version__ = \"3.5.0\"\n+\n+def _parse_version_info(version_str):\n+    \"\"\"Parse *version_str* into a version_info-style tuple.\n+\n+    This function intentionally only supports the standard\n+    \"major.minor.micro\" core of the version string and ignores any\n+    local or pre-release suffixes for the purpose of comparison.\n+    \"\"\"\n+    core = version_str.split(\"+\", 1)[0].split(\"-\", 1)[0]\n+    parts = core.split(\".\")\n+    major, minor, micro = (int(p) for p in parts[:3])\n+    return (major, minor, micro, \"final\", 0)\n+\n+version_info = _parse_version_info(__version__)\n \n-# Other tooling may read __version__ from here.\n+__all__ = [\"__version__\", \"version_info\"]\n\ndiff --git a/lib/matplotlib/__init__.py b/lib/matplotlib/__init__.py\nindex 33333333..44444444 100644\n--- a/lib/matplotlib/__init__.py\n+++ b/lib/matplotlib/__init__.py\n@@ -30,8 +30,11 @@\n-# The top level __version__ is imported from the internal version module.\n-from . import _version\n-__version__ = _version.__version__\n+\"\"\"Top-level Matplotlib package.\"\"\"\n+\n+# The top level __version__ and version_info are imported from the\n+# internal version module, which is kept as the single source of truth\n+# for version information.\n+from . import _version\n+__version__ = _version.__version__\n+version_info = _version.version_info\n@@ -50,7 +53,8 @@ __all__ = [\n-    \"__version__\",\n+    \"__version__\",\n+    \"version_info\",\n     # lots of other public names...\n ]\n</patch>\n<|im_end|>"}
{"instance_id": "matplotlib__matplotlib-22835", "problem": "仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22835\n\nIssue 描述：\n[Bug]: scalar mappable format_cursor_data crashes on BoundaryNorm\n\n在 3.5.0 中，如果使用 `mpl.colors.BoundaryNorm` 作为 norm 绘制图像，在窗口中将鼠标悬停到图像上时，会触发 `Artist.format_cursor_data` 调用 `norm.inverse`，而 `BoundaryNorm.inverse` 抛出 `ValueError(\"BoundaryNorm is not invertible\")`，从而使交互完全中断。\nIssue 讨论希望在这种不可逆 norm 的场景下避免崩溃，可以是特殊检查或 try/except 处理。\n", "snippets": [], "gold_patch": "<|im_start|>user\n你是一个资深的代码修复助手。如果用户使用中文提问，请务必全程使用中文进行思考和回答。请先在 <think> 中用中文分 3-5 步、每步不超过两句话，简要分析问题原因，然后【必须】在 <patch>...</patch> 中给出可以应用到对应仓库的英文补丁代码，补丁格式必须是标准 unified diff（以 diff --git 开头，包含 ---/+++/@@ 这些标记）。\n\n仓库：matplotlib/matplotlib\ncommit：DUMMY_COMMIT_HASH_22835\n\nIssue 描述：\n[Bug]: scalar mappable format_cursor_data crashes on BoundaryNorm\n\n使用 `BoundaryNorm` 作为归一化器绘制图像时，鼠标悬停会触发 `Artist.format_cursor_data`，调用 `norm.inverse` 时 `BoundaryNorm` 抛出 `ValueError(\"BoundaryNorm is not invertible\")`，导致交互崩溃。\n<|im_end|>\n<|im_start|>assistant\n<think>\n第1步：该 bug 只在使用 `BoundaryNorm` 时出现，说明问题特定于这种离散边界归一化器，而不是所有 norm 实现。\n第2步：`BoundaryNorm` 设计上是通过分段边界将连续数据映射到离散颜色索引，本身在数学上不可逆，因此其 `inverse` 显式抛出 `ValueError` 提示 \"BoundaryNorm is not invertible\"。\n第3步：`Artist.format_cursor_data` 目前假定 `norm.inverse` 总是可用且成功，没有捕获这种异常，导致当 norm 不可逆时整个交互栈被中断，这是防御性编程不足。\n第4步：合理修复是在 `format_cursor_data` 中对 `norm.inverse` 的调用加一层 try/except，捕获包括 `ValueError` 在内的异常；当无法逆变换时，优雅地退化为显示原始数据值或简单字符串，而不是让异常冒泡。\n第5步：这种处理方式对可逆 norm 行为无影响，只是在特定 norm 不支持 inverse 时提供了平滑降级，保证交互工具的稳定性。\n</think>\n<patch>\ndiff --git a/lib/matplotlib/artist.py b/lib/matplotlib/artist.py\nindex 55555555..66666666 100644\n--- a/lib/matplotlib/artist.py\n+++ b/lib/matplotlib/artist.py\n@@ -1270,16 +1270,34 @@ class Artist:\n     def format_cursor_data(self, data):\n         \"\"\"Return a string representation of *data*.\n \n         This is intended for interactive tools; subclasses may override this\n         to return a custom string representation.\n         \"\"\"\n-        if self.norm is not None:\n-            neighbors = self.norm.inverse(data)\n-            return str(neighbors)\n-        return str(data)\n+        # Some ScalarMappables attach a norm that supports an \"inverse\"\n+        # transformation (e.g., LinearNorm), which can be useful to map from\n+        # display coordinates back to data space for cursor readouts.  However,\n+        # not all norms are mathematically invertible; BoundaryNorm, for\n+        # example, is designed around discrete boundaries and explicitly\n+        # raises ``ValueError(\"BoundaryNorm is not invertible\")`` when its\n+        # ``inverse`` is called.\n+\n+        if self.norm is not None:\n+            try:\n+                neighbors = self.norm.inverse(data)\n+            except (AttributeError, TypeError, ValueError):\n+                # If the norm does not provide an inverse, or declares itself\n+                # non-invertible (e.g. BoundaryNorm), fall back to the original\n+                # data value rather than raising and breaking interactive tools.\n+                return str(data)\n+            else:\n+                return str(neighbors)\n+\n+        return str(data)\n</patch>\n<|im_end|>"}
